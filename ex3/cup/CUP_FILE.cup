/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import ast.*;

parser code 
{:
	public Lexer lexer;

	public boolean lexError = false;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	public void report_error(String message, Object info)
	{
		throw new RuntimeException("ERROR(" + lexer.getLine() + ")");
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	//System.out.print("[");
	//System.out.print(lexer.getLine());
	//System.out.print(":");
	//System.out.print(lexer.getTokenStartPosition());
	//System.out.print("] ");
	//System.out.print(TokenNames.terminalNames[s.sym]);
	//if (s.value != null)
	//{
	//	System.out.print("( ");
	//	System.out.print(s.value);
	//	System.out.print(" )");
	//}
	//System.out.print("\n");
	return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal SEMICOLON;
terminal ASSIGN;
terminal COMMA;
terminal TYPE_INT;
terminal TYPE_STRING;
terminal TYPE_VOID;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal RETURN;
terminal ELSE;
terminal NEW;
terminal EXTENDS;
terminal NIL;

/*************/
/* TERMINALS */
/*************/
terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstExp		 		exp;
non terminal AstExpList			expList;
non terminal AstNewExp			newExp;
non terminal AstCallExp			callExp;
non terminal AstVar				var;
non terminal AstStmt 	 		stmt;
non terminal AstStmtList 		stmtList;
non terminal AstProgram	 		program;
non terminal AstDec 			dec;
non terminal AstVarDec 			varDec;
non terminal AstFuncDec 		funcDec;
non terminal AstFuncArg			funcArg;
non terminal AstFuncArgList 	funcArgList;
non terminal AstClassDec 		classDec;
non terminal AstCfield	 		cField;
non terminal AstCfieldList 		cFieldList;
non terminal AstArrayTypeDef	arrayTypeDef;
non terminal AstType	 		type;


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence right ASSIGN;
precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left DOT;


/************************/
/* START WITH: program */
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/
program		::=		dec:d				{: RESULT = new AstProgram(d, null, dleft);	:}
					| dec:d program:p	{: RESULT = new AstProgram(d, p, dleft);	:}
					;

dec			::=		varDec:d			{: RESULT = new AstDecVarDec(d, dleft);			:}
					| funcDec:d			{: RESULT = new AstDecFuncDec(d, dleft);		:}
					| classDec:d		{: RESULT = new AstDecClassDec(d, dleft);		:}
					| arrayTypeDef:d	{: RESULT = new AstDecArrayTypeDef(d, dleft);	:}
					;

type		::=		TYPE_INT:t		{: RESULT = new AstType(0, null, tleft);	:}
					| TYPE_STRING:t	{: RESULT = new AstType(1, null, tleft);	:}
					| TYPE_VOID:t	{: RESULT = new AstType(2, null, tleft);	:}
					| ID:d			{: RESULT = new AstType(3, d, dleft);		:}
					;

varDec		::=		type:t ID:fieldName SEMICOLON						{: RESULT = new AstVarDec(t, fieldName, null, null, tleft);		:}
					| type:t ID:fieldName ASSIGN exp:e SEMICOLON		{: RESULT = new AstVarDec(t, fieldName, e, null, tleft);  		:}
					| type:t ID:fieldName ASSIGN newExp:e SEMICOLON		{: RESULT = new AstVarDec(t, fieldName, null, e, tleft);		:}
					;

funcDec		::=		type:t ID:fieldName LPAREN RPAREN LBRACE stmtList:sl RBRACE	{: RESULT = new AstFuncDec(t, fieldName, null, sl, tleft);  					:}
					| type:t ID:fieldName LPAREN funcArgList:al RPAREN LBRACE stmtList:sl RBRACE	{: RESULT = new AstFuncDec(t, fieldName, al, sl, tleft);	:}
					;

funcArg		::=		type:t ID:fieldName	{: RESULT = new AstFuncArg(t, fieldName, tleft);	:}
					;

funcArgList	::=		funcArg:a					{: RESULT = new AstFuncArgList(a, null, aleft);:}
					| funcArg:a COMMA funcArgList:al	{: RESULT = new AstFuncArgList(a, al, aleft);	:}
					;

stmtList	::=		stmt:s	stmtList:l		{: RESULT = new AstStmtList(s,l, sleft);    :}
					| stmt:s				{: RESULT = new AstStmtList(s,null, sleft); :}
					;

classDec	::=		CLASS ID:className LBRACE cFieldList:cl RBRACE							{: RESULT = new AstClassDec(className, null, cl, classNameleft);      :}
					| CLASS ID:className EXTENDS ID:extendName LBRACE cFieldList:cl RBRACE	{: RESULT = new AstClassDec(className, extendName, cl, classNameleft);:}
					;

cField		::=		varDec:v	{: RESULT = new AstCfield(v, null, vleft);:}
					| funcDec:f	{: RESULT = new AstCfield(null, f, fleft);:}
					;

cFieldList	::=		cField:cf	{: RESULT = new AstCfieldList(cf, null, cfleft);          		:}
					| cField:cf cFieldList:cfl	{: RESULT = new AstCfieldList(cf, cfl, cfleft);	:}
					;

arrayTypeDef::=		ARRAY:a ID:fieldName EQ type:t LBRACK RBRACK SEMICOLON	{: RESULT = new AstArrayTypeDef(fieldName, t, aleft);:}
					;

var			::=		ID:name						{: RESULT = new AstVarSimple(name, nameleft);       :}
					| var:v DOT ID:fieldName	{: RESULT = new AstVarField(v,fieldName, vleft); :}
					| var:v LBRACK exp:e RBRACK	{: RESULT = new AstVarSubscript(v,e, vleft);     :}
					;
					
stmt		::=		varDec:v																						{: RESULT = new AstStmtVarDec(v, vleft);          		:}
					| var:v ASSIGN exp:e SEMICOLON																	{: RESULT = new AstStmtAssign(v, e, vleft); 			:}
					| var:v ASSIGN newExp:e SEMICOLON																{: RESULT = new AstStmtAssign(v, e, vleft); 			:}
					| RETURN:r SEMICOLON																			{: RESULT = new AstStmtReturn(null, rleft);    			:}
					| RETURN:r exp:e SEMICOLON																		{: RESULT = new AstStmtReturn(e, rleft);      			:}
					| IF:i LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE										{: RESULT = new AstStmtIf(cond, body, null, ileft); 	:}
					| IF:i LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE ELSE LBRACE stmtList:elseBody RBRACE	{: RESULT = new AstStmtIf(cond, body, elseBody, ileft); :}
					| WHILE:w LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE									{: RESULT = new AstStmtWhile(cond,body, wleft);			:}
					| callExp:ce SEMICOLON																			{: RESULT = new AstStmtCallExp(ce, celeft);         	:}
					;

exp			::=		var:v								{: RESULT = new AstExpVar(v, vleft);          	:}
					| LPAREN exp:e RPAREN				{: RESULT = e;         							:}
					| exp:e1 PLUS  exp:e2				{: RESULT = new AstExpBinop(e1, e2, 0, e1left);	:}
					| exp:e1 MINUS exp:e2				{: RESULT = new AstExpBinop(e1, e2, 1, e1left);	:}
					| exp:e1 TIMES exp:e2				{: RESULT = new AstExpBinop(e1, e2, 2, e1left);	:}
					| exp:e1 DIVIDE exp:e2				{: RESULT = new AstExpBinop(e1, e2, 3, e1left);	:}
					| exp:e1 LT exp:e2					{: RESULT = new AstExpBinop(e1, e2, 4, e1left);	:}
					| exp:e1 GT exp:e2					{: RESULT = new AstExpBinop(e1, e2, 5, e1left);	:}
					| exp:e1 EQ exp:e2					{: RESULT = new AstExpBinop(e1, e2, 6, e1left);	:}
					| callExp:ce						{: RESULT = new AstExpCallExp(ce, celeft);		:}
					| INT:i 							{: RESULT = new AstExpInt(i, ileft);         	:}
					| MINUS INT:i 						{: RESULT = new AstExpInt(-i, ileft);        	:}
					| NIL:n 							{: RESULT = new AstExpNill(nleft);				:}
					| STRING:s 							{: RESULT = new AstExpString(s, sleft);			:}
					;

newExp		::=		NEW type:t							{: RESULT = new AstNewExp(t, null, tleft);	:}
					| NEW type:t LBRACK exp:e RBRACK	{: RESULT = new AstNewExp(t, e, tleft);	:}
					;

expList		::=		exp:e					{: RESULT = new AstExpList(e, null, eleft);	:}
					| exp:e COMMA expList:l	{: RESULT = new AstExpList(e, l, eleft);	:}
					;

callExp		::=		ID:fieldName LPAREN RPAREN 							{: RESULT = new AstCallExp(null, fieldName, null, fieldNameleft);	:}
					| var:v DOT ID:fieldName LPAREN RPAREN 				{: RESULT = new AstCallExp(v, fieldName, null, fieldNameleft);     	:}
					| ID:fieldName LPAREN expList:el RPAREN 			{: RESULT = new AstCallExp(null, fieldName, el, fieldNameleft);    	:}
					| var:v DOT ID:fieldName LPAREN expList:el RPAREN 	{: RESULT = new AstCallExp(v, fieldName, el, fieldNameleft);       	:}
					;